<html><head>
<link rel="stylesheet" type="text/css" href="https://categoricaldata.net/css/simple.css" /></head><body><h1>example corner_cases</h1><pre>
constraints c = literal : (empty : empty) {
	forall where -&gt; exists where
}


typeside ty = literal {
	types nat
	functions 0 1 2 3 : -&gt; nat   s : nat -&gt; nat    p : nat, nat -&gt; nat
}

constraints c1 = literal : (empty : ty) {
	-&gt; exists where p(0,0)=0.s
}

instance I = literal : (empty : ty) {
	equations
		p(0,0)=0.s	
	options
		require_consistency=false	
}

schema s = literal : ty {
	entities e
	attributes att : e -&gt; nat
}

mapping m = literal : s -&gt; s {
	entity
		e -&gt; e
	attributes 
		att -&gt; lambda x. p(0,p(x.att, att(x)))
}


query q = literal : s -&gt; s {
	entity
		e -&gt; {from where
	attributes 
		att -&gt; p(0,0.s)}
}


schema s2 = literal : ty {
	entities e
	//foreign_keys f : e -&gt; e
	attributes att : e -&gt; nat
	observation_equations
		forall x. x.att.s = 0
}


/* In Instance,
 * instanceColimitNode : instanceRef RARROW instanceKind ;
instanceColimitEdge : schemaArrowId RARROW transformKind ;

should be (or possibly + instead of *)

instanceColimitNode : instanceRef* RARROW instanceKind ;
instanceColimitEdge : schemaArrowId* RARROW transformKind ;

In CQL, most places x : y is allowed so is x w z : y
 */

 /*
  * csv files have 'per block' options - important in practice
  * 
instance I0 = import_csv "/Users/ryan/Desktop/" : S0 {
	Employee -&gt; {Employee -&gt; eId   eAsP -&gt; is    eSsn -&gt; is
	options prover = auto
	}
	//eId -&gt; eId can be ommitted
	
	Person -&gt; {Person -&gt; pId  ssn -&gt; pId  options prover = auto}
}
*/



/*
 * This confused me.  attribute mappings are of the form
 * v -&gt; lambda x:t. e
 * where :t is optional and e is a term (e.g., f(x,y) or p.q or 3 etc)
 * note it is critical that there be exactly one x (i.e., e must have 1 free var)
 * 
 mappingAttributeTerm
  : LAMBDA mappingGen (COMMA mappingGen)* DOT evalMappingFn
  # MappingAttrTerm_Lambda
*/

/*
 * I don't think this is implemented - colimits in the category of schemas and queries may
 * be very different that colimits in the category of schemas and mappings.
 * 
  | GET_MAPPING schemaColimitKind schemaRef
  #QueryExp_Get

  */

 /* aql doesn't treat true and false specially as e.g., the ANTLR grammar does */
 /* does it really work to import 'sql' in a typeside? */
</pre> Keywords:<br/></br>			<a href="constraintsconstraints_literal.html" >constraints_literal</a><br />
			<a href="typesidetypeside_literal.html" >typeside_literal</a><br />
			<a href="instanceinstance_literal.html" >instance_literal</a><br />
			<a href="schemaschema_literal.html" >schema_literal</a><br />
			<a href="mappingmapping_literal.html" >mapping_literal</a><br />
			<a href="queryquery_literal.html" >query_literal</a><br />
<br/>Options:<br/></br><a href="require_consistency.html" >require_consistency</a><br/>

<br/></br>
<hr/><h3>instance I</h3><div></div><br style="clear:both;"/></body></html>